import {
  emit,
  loadSettingsAsync,
  on,
  saveSettingsAsync,
  showUI,
} from "@create-figma-plugin/utilities";
import {
  figmaNameWithNumberRegex,
  isFigmaGeneratedName,
  isValidFigmaNodeType,
} from "./figma-node-types";
import { NamingStrategyManager } from "./naming-strategies/manager";
import { AllOptions } from "./types";

/**
 * 定义插件可以识别和处理的自动生成图层名称列表
 * 这些名称通常由设计工具或其他插件自动创建
 */
const PLUGIN_GENERATED_NAMES = [
  "group",
  "frame",
  "grid",
  "row",
  "col",
  "video",
  "image",
  "union",
  "subtract",
  "intersect",
  "exclude",
];

/**
 * 创建用于匹配插件生成名称的正则表达式
 * 格式: name-[number] 或 name-[number,number]
 * 例如: "frame-[1]" 或 "grid-[1,2]"
 */
const PLUGIN_NAME_PATTERN = new RegExp(
  `^(${PLUGIN_GENERATED_NAMES.join("|")})(-\\[\\d+(?:,\\s*\\d+)?\\])?$`,
  "i"
);

/**
 * 根据节点类型验证名称是否为插件生成
 * @param node - Figma 场景节点，用于检查其类型和属性
 * @param name - 节点名称（小写），需要验证的名称字符串
 * @returns {boolean} 如果名称与节点类型匹配则返回 true
 */
function isPluginGeneratedNameBasedOnType(
  node: SceneNode,
  name: string
): boolean {
  // 移除可能的间距信息后再进行匹配
  const baseName = name.replace(/-\[\d+(?:,\s*\d+)?\]$/, "");

  switch (baseName) {
    case "group":
      return node.type === "GROUP";
    case "frame":
    case "grid":
    case "row":
    case "col":
      return node.type === "FRAME";
    case "image":
    case "video":
      return (
        "fills" in node &&
        (node.fills as Paint[]).some(
          (fill) => fill.type === baseName.toUpperCase()
        )
      );
    case "union":
    case "subtract":
    case "intersect":
    case "exclude":
      return (
        node.type === "BOOLEAN_OPERATION" &&
        (node as BooleanOperationNode).booleanOperation.toLowerCase() ===
          baseName
      );
    default:
      return false;
  }
}

// 初始化命名策略管理器
const namingManager = new NamingStrategyManager();

/**
 * 重命名单个图层的核心逻辑
 * 包含以下判断：
 * 1. 检查图层是否需要跳过（锁定/隐藏/实例）
 * 2. 验证是否需要重命名（自定义名称或自动生成名称）
 * 3. 处理命名规则（如 PascalCase）
 * @param node - 需要重命名的 Figma 场景节点
 * @param options - 重命名配置选项，包含是否处理锁定/隐藏/实例等设置
 * @returns {Promise<boolean>} 如果节点被重命名则返回 true，否则返回 false
 * @throws 当重命名过程出错时抛出异常
 */
async function renameLayer(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  try {
    // 根据选项跳过特定类型的图层
    if (node.locked && !options.locked) return false;
    if (node.visible === false && !options.hidden) return false;
    if (node.type === "INSTANCE" && !options.instance) return false;

    // 检查是否需要重命名
    const shouldRename =
      options.renameCustomNames || isFigmaOrPluginGeneratedName(node);

    // 添加强制重命名的条件
    const isAutoGeneratedName = PLUGIN_NAME_PATTERN.test(node.name);
    const needsCaseUpdate = options.usePascalCase !== /^[A-Z]/.test(node.name);

    if (!shouldRename && !(isAutoGeneratedName && needsCaseUpdate)) {
      return false;
    }

    const newName = await namingManager.generateName(node, options);
    if (node.name !== newName) {
      node.name = newName;
      return true;
    }
    return false;
  } catch (error) {
    console.error(`重命名错误 (${node.id}):`, error);
    figma.notify(`重命名失败: ${node.name}`, { error: true });
    return false;
  }
}

/**
 * 批量处理节点的重命名操作
 * 使用分批处理避免性能问题：
 * - 每批处理 50 个节点
 * - 批次间添加微小延迟避免阻塞主线程
 * @param nodes - 需要处理的 Figma 场景节点数组
 * @param options - 重命名配置选项
 * @returns {Promise<boolean>} 如果任何节点被重命名则返回 true
 */
async function processBatchNodes(
  nodes: readonly SceneNode[],
  options: AllOptions
): Promise<boolean> {
  const batchSize = 50;
  let hasRenamed = false;

  for (let i = 0; i < nodes.length; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize);
    const results = await Promise.all(
      batch.map((node) => renameNodeAndChildren(node, options))
    );
    hasRenamed = hasRenamed || results.some((result) => result);

    // 每批处理完后暂停一下，避免阻塞主线程
    if (i + batchSize < nodes.length) {
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }

  return hasRenamed;
}

/**
 * 重命名选中的图层
 * @param options 重命名选项
 * @returns 是否有任何图层被重命名
 */
function renameLayersInSelection(options: AllOptions): Promise<boolean> {
  return new Promise(async (resolve) => {
    const selection = figma.currentPage.selection;
    const hasRenamed = await processBatchNodes(selection, options);
    resolve(hasRenamed);
  });
}

/**
 * 检查节点是否在实例内
 * @param node - 要检查的节点
 * @returns 如果节点在实例内则返回 true
 */
function isInsideInstance(node: SceneNode): boolean {
  let currentNode: BaseNode | null = node;
  while (currentNode) {
    if (currentNode.type === "INSTANCE") {
      return true;
    }
    currentNode = currentNode.parent;
  }
  return false;
}

/**
 * 递归函数，用于重命名节点及其子节点
 * @param node 要处理的节点
 * @param options 重命名选项
 * @returns 是否有任何节点被重命名
 */
async function renameNodeAndChildren(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  // 如果节点在实例内且未启用实例重命名，直接返回
  if (isInsideInstance(node) && !options.instance) {
    return false;
  }

  let hasRenamed = await renameLayer(node, options);

  // 只有在非实例节点或启用了实例重命名的情况下才处理子节点
  if ("children" in node && (node.type !== "INSTANCE" || options.instance)) {
    const childResults = await Promise.all(
      node.children.map((child) => renameNodeAndChildren(child, options))
    );
    hasRenamed = hasRenamed || childResults.some((result) => result);
  }

  return hasRenamed;
}

/**
 * 判断节点名称是否为自动生成
 * 检查三种情况：
 * 1. 文本节点的自动重命名标志
 * 2. 组件相关的默认命名
 * 3. Figma 默认生成的名称
 * 4. 插件生成的名称
 * @param node - 要检查的 Figma 场景节点
 * @returns {boolean} 如果节点名称是自动生成的则返回 true
 */
function isFigmaOrPluginGeneratedName(node: SceneNode): boolean {
  const name = node.name.toLowerCase();

  // 验证节点类型
  if (!isValidFigmaNodeType(node.type)) {
    console.warn(`未知的 Figma 节点类型: ${node.type}`);
    return false;
  }

  // 处理文本节点
  if (node.type === "TEXT") {
    return (node as TextNode).autoRename || name === "text";
  }

  // 组件类型的特殊处理
  if (node.type === "COMPONENT" || node.type === "COMPONENT_SET") {
    return (
      name === "component" ||
      name === "componentset" ||
      figmaNameWithNumberRegex.test(name)
    );
  }

  // 检查是否为 Figma 生成的名称，传入节点类型进行匹配
  if (isFigmaGeneratedName(node)) {
    return true;
  }

  // 根据节点类型和名称的关系判断是否是插件生成的名称
  return isPluginGeneratedNameBasedOnType(node, name);
}

/**
 * 插件入口函数
 * 主要职责：
 * 1. 初始化 UI 和配置
 * 2. 设置事件监听器
 * 3. 处理用户交互和重命名操作
 */
export default async function () {
  // 加载保存的设置
  const savedOptions: AllOptions = await loadSettingsAsync(
    {
      locked: false,
      hidden: false,
      instance: false,
      showSpacing: false,
      renameCustomNames: false,
      usePascalCase: false,
      language: "en", // 添加默认语言设置
    },
    "allOptions"
  );

  // 根据语言设置初始高度
  const initialHeight = savedOptions.language === "zh" ? 262 : 246;

  // 设置 UI 窗口大小
  const uiOptions = {
    width: 240,
    height: initialHeight,
  };

  const data = {
    savedOptions: savedOptions,
    initialSelection: figma.currentPage.selection.length > 0,
  };

  // 显示 UI
  showUI(uiOptions, data);

  // 监听选中变化
  figma.on("selectionchange", () => {
    emit("SELECTION_CHANGED", figma.currentPage.selection.length > 0);
  });

  // 监听 UI 设置面板开关事件
  on("SETTING_OPEN", (data: { settingOpen: boolean; language: string }) => {
    const baseHeight = data.language === "zh" ? 262 : 246;
    figma.ui.resize(240, data.settingOpen ? 456 : baseHeight);
  });

  // 监听重命名事件
  on("RENAME", async (receivedOptions: AllOptions) => {
    try {
      // 设置实例子节点的可见性处理
      figma.skipInvisibleInstanceChildren = !(
        receivedOptions.instance && receivedOptions.hidden
      );

      // 保存用户的选项
      await saveSettingsAsync(receivedOptions, "allOptions");

      // 执行重命名操作
      const hasRenamed = await renameLayersInSelection(receivedOptions);

      // 显示操作结果通知
      if (hasRenamed) {
        figma.notify("🎉 重命名完成！");
      } else {
        figma.notify("😶‍🌫️ 没有图层需要重命名");
      }
    } catch (error) {
      console.error("重命名过程出错:", error);
      figma.notify("❌ 重命名过程中出现错误", { error: true });
    }
  });

  // 添加保存设置的事件监听
  on("SAVE_SETTINGS", async (options: AllOptions) => {
    try {
      await saveSettingsAsync(options, "allOptions");
    } catch (error) {
      console.error("保存设置失败:", error);
      figma.notify("设置保存失败", { error: true });
    }
  });
}
