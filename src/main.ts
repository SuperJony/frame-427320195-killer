import {
  emit,
  loadSettingsAsync,
  on,
  saveSettingsAsync,
  showUI,
} from "@create-figma-plugin/utilities";
import { isFigmaGeneratedName, isValidFigmaNodeType } from "./figma-node-types";
import { NamingStrategyManager } from "./naming-strategies/manager";
import { AllOptions } from "./types";

// å®šä¹‰æ’ä»¶ç”Ÿæˆçš„å›¾å±‚åç§°åˆ—è¡¨
const PLUGIN_GENERATED_NAMES = [
  "group",
  "frame",
  "grid",
  "row",
  "col",
  "video",
  "image",
  "union",
  "subtract",
  "intersect",
  "exclude",
];

// åˆ›å»ºæ’ä»¶ç”Ÿæˆçš„å›¾å±‚åç§°æ¨¡å¼çš„æ­£åˆ™è¡¨è¾¾å¼
const PLUGIN_NAME_PATTERN = new RegExp(
  `^(${PLUGIN_GENERATED_NAMES.join("|")})(-\\[\\d+(?:,\\s*\\d+)?\\])?$`,
  "i"
);

// åˆå§‹åŒ–å‘½åç­–ç•¥ç®¡ç†å™¨
const namingManager = new NamingStrategyManager();

/**
 * é‡å‘½åå•ä¸ªå›¾å±‚
 * @param node è¦é‡å‘½åçš„å›¾å±‚èŠ‚ç‚¹
 * @param options é‡å‘½åé€‰é¡¹
 * @returns å¦‚æœå›¾å±‚è¢«é‡å‘½ååˆ™è¿”å› Promise<boolean>
 */
async function renameLayer(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  try {
    // æ ¹æ®é€‰é¡¹è·³è¿‡ç‰¹å®šç±»å‹çš„å›¾å±‚
    if (node.locked && !options.locked) return false;
    if (node.visible === false && !options.hidden) return false;
    if (node.type === "INSTANCE" && !options.instance) return false;

    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å‘½å
    const shouldRename =
      options.renameCustomNames || isFigmaOrPluginGeneratedName(node);

    // æ·»åŠ å¼ºåˆ¶é‡å‘½åçš„æ¡ä»¶
    const isAutoGeneratedName = PLUGIN_NAME_PATTERN.test(node.name);
    const needsCaseUpdate = options.usePascalCase !== /^[A-Z]/.test(node.name);

    if (!shouldRename && !(isAutoGeneratedName && needsCaseUpdate)) {
      return false;
    }

    const newName = await namingManager.generateName(node, options);
    if (node.name !== newName) {
      node.name = newName;
      return true;
    }
    return false;
  } catch (error) {
    console.error(`é‡å‘½åé”™è¯¯ (${node.id}):`, error);
    figma.notify(`é‡å‘½åå¤±è´¥: ${node.name}`, { error: true });
    return false;
  }
}

/**
 * æ‰¹é‡å¤„ç†èŠ‚ç‚¹
 * @param nodes è¦å¤„ç†çš„èŠ‚ç‚¹æ•°ç»„
 * @param options é‡å‘½åé€‰é¡¹
 */
async function processBatchNodes(
  nodes: readonly SceneNode[],
  options: AllOptions
): Promise<boolean> {
  const batchSize = 50;
  let hasRenamed = false;

  for (let i = 0; i < nodes.length; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize);
    const results = await Promise.all(
      batch.map((node) => renameNodeAndChildren(node, options))
    );
    hasRenamed = hasRenamed || results.some((result) => result);

    // æ¯æ‰¹å¤„ç†å®Œåæš‚åœä¸€ä¸‹ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
    if (i + batchSize < nodes.length) {
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }

  return hasRenamed;
}

/**
 * é‡å‘½åé€‰ä¸­çš„å›¾å±‚
 * @param options é‡å‘½åé€‰é¡¹
 * @returns æ˜¯å¦æœ‰ä»»ä½•å›¾å±‚è¢«é‡å‘½å
 */
function renameLayersInSelection(options: AllOptions): Promise<boolean> {
  return new Promise(async (resolve) => {
    const selection = figma.currentPage.selection;
    const hasRenamed = await processBatchNodes(selection, options);
    resolve(hasRenamed);
  });
}

/**
 * æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨å®ä¾‹å†…
 * @param node - è¦æ£€æŸ¥çš„èŠ‚ç‚¹
 * @returns å¦‚æœèŠ‚ç‚¹åœ¨å®ä¾‹å†…åˆ™è¿”å› true
 */
function isInsideInstance(node: SceneNode): boolean {
  let currentNode: BaseNode | null = node;
  while (currentNode) {
    if (currentNode.type === "INSTANCE") {
      return true;
    }
    currentNode = currentNode.parent;
  }
  return false;
}

/**
 * é€’å½’å‡½æ•°ï¼Œç”¨äºé‡å‘½åèŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹
 * @param node è¦å¤„ç†çš„èŠ‚ç‚¹
 * @param options é‡å‘½åé€‰é¡¹
 * @returns æ˜¯å¦æœ‰ä»»ä½•èŠ‚ç‚¹è¢«é‡å‘½å
 */
async function renameNodeAndChildren(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  // å¦‚æœèŠ‚ç‚¹åœ¨å®ä¾‹å†…ä¸”æœªå¯ç”¨å®ä¾‹é‡å‘½åï¼Œç›´æ¥è¿”å›
  if (isInsideInstance(node) && !options.instance) {
    return false;
  }

  let hasRenamed = await renameLayer(node, options);

  // åªæœ‰åœ¨éå®ä¾‹èŠ‚ç‚¹æˆ–å¯ç”¨äº†å®ä¾‹é‡å‘½åçš„æƒ…å†µä¸‹æ‰å¤„ç†å­èŠ‚ç‚¹
  if ("children" in node && (node.type !== "INSTANCE" || options.instance)) {
    const childResults = await Promise.all(
      node.children.map((child) => renameNodeAndChildren(child, options))
    );
    hasRenamed = hasRenamed || childResults.some((result) => result);
  }

  return hasRenamed;
}

/**
 * åˆ¤æ–­å›¾å±‚åç§°æ˜¯å¦ä¸º Figma æˆ–æ’ä»¶è‡ªåŠ¨ç”Ÿæˆçš„
 * @param node å›¾å±‚èŠ‚ç‚¹
 * @returns æ˜¯å¦ä¸º Figma æˆ–æ’ä»¶è‡ªåŠ¨ç”Ÿæˆçš„åç§°
 */
function isFigmaOrPluginGeneratedName(node: SceneNode): boolean {
  const name = node.name.toLowerCase();

  // éªŒè¯èŠ‚ç‚¹ç±»å‹
  if (!isValidFigmaNodeType(node.type)) {
    console.warn(`æœªçŸ¥çš„ Figma èŠ‚ç‚¹ç±»å‹: ${node.type}`);
    return false;
  }

  // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹
  if (node.type === "TEXT") {
    return (node as TextNode).autoRename || name === "text";
  }

  // ç»„ä»¶ç±»å‹çš„ç‰¹æ®Šå¤„ç†
  if (node.type === "COMPONENT" || node.type === "COMPONENT_SET") {
    return (
      name === "component" || name === "componentset" || /^\S+\s\d+$/.test(name)
    );
  }

  // æ£€æŸ¥æ˜¯å¦ä¸º Figma ç”Ÿæˆçš„åç§°
  if (isFigmaGeneratedName(name)) {
    return true;
  }

  // æ£€æŸ¥æ˜¯å¦åŒ¹é…æ’ä»¶ç”Ÿæˆçš„åç§°æ¨¡å¼
  return PLUGIN_NAME_PATTERN.test(name);
}

/**
 * æ’ä»¶ä¸»å‡½æ•°
 */
export default async function () {
  // è®¾ç½® UI çª—å£å¤§å°
  const uiOptions = {
    width: 240,
    height: 262,
  };

  // åŠ è½½ä¿å­˜çš„è®¾ç½®
  const savedOptions: AllOptions = await loadSettingsAsync(
    {
      locked: false,
      hidden: false,
      instance: false,
      showSpacing: false,
      renameCustomNames: false,
      usePascalCase: false,
    },
    "allOptions"
  );

  const data = {
    savedOptions: savedOptions,
    initialSelection: figma.currentPage.selection.length > 0,
  };

  // æ˜¾ç¤º UI
  showUI(uiOptions, data);

  // ç›‘å¬é€‰ä¸­å˜åŒ–
  figma.on("selectionchange", () => {
    emit("SELECTION_CHANGED", figma.currentPage.selection.length > 0);
  });

  // ç›‘å¬ UI è®¾ç½®é¢æ¿å¼€å…³äº‹ä»¶
  on("SETTING_OPEN", (settingOpen: boolean) => {
    figma.ui.resize(240, settingOpen ? 262 : 408);
  });

  // ç›‘å¬é‡å‘½åäº‹ä»¶
  on("RENAME", async (receivedOptions: AllOptions) => {
    try {
      // è®¾ç½®å®ä¾‹å­èŠ‚ç‚¹çš„å¯è§æ€§å¤„ç†
      figma.skipInvisibleInstanceChildren = !(
        receivedOptions.instance && receivedOptions.hidden
      );

      // ä¿å­˜ç”¨æˆ·çš„é€‰é¡¹
      await saveSettingsAsync(receivedOptions, "allOptions");

      // æ‰§è¡Œé‡å‘½åæ“ä½œ
      const hasRenamed = await renameLayersInSelection(receivedOptions);

      // æ˜¾ç¤ºæ“ä½œç»“æœé€šçŸ¥
      if (hasRenamed) {
        figma.notify("ğŸ‰ é‡å‘½åå®Œæˆï¼");
      } else {
        figma.notify("ğŸ˜¶â€ğŸŒ«ï¸ æ²¡æœ‰å›¾å±‚éœ€è¦é‡å‘½å");
      }
    } catch (error) {
      console.error("é‡å‘½åè¿‡ç¨‹å‡ºé”™:", error);
      figma.notify("âŒ é‡å‘½åè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯", { error: true });
    }
  });
}
