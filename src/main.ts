import {
  emit,
  loadSettingsAsync,
  on,
  saveSettingsAsync,
  showUI,
} from "@create-figma-plugin/utilities";
import {
  figmaNameWithNumberRegex,
  isFigmaGeneratedName,
  isValidFigmaNodeType,
} from "./figma-node-types";
import { NamingStrategyManager } from "./naming-strategies/manager";
import { AllOptions } from "./types";

/**
 * å®šä¹‰æ’ä»¶å¯ä»¥è¯†åˆ«å’Œå¤„ç†çš„è‡ªåŠ¨ç”Ÿæˆå›¾å±‚åç§°åˆ—è¡¨
 * è¿™äº›åç§°é€šå¸¸ç”±è®¾è®¡å·¥å…·æˆ–å…¶ä»–æ’ä»¶è‡ªåŠ¨åˆ›å»º
 */
const PLUGIN_GENERATED_NAMES = [
  "group",
  "frame",
  "grid",
  "row",
  "col",
  "video",
  "image",
  "union",
  "subtract",
  "intersect",
  "exclude",
];

/**
 * åˆ›å»ºç”¨äºåŒ¹é…æ’ä»¶ç”Ÿæˆåç§°çš„æ­£åˆ™è¡¨è¾¾å¼
 * æ ¼å¼: name-[number] æˆ– name-[number,number]
 * ä¾‹å¦‚: "frame-[1]" æˆ– "grid-[1,2]"
 */
const PLUGIN_NAME_PATTERN = new RegExp(
  `^(${PLUGIN_GENERATED_NAMES.join("|")})(-\\[\\d+(?:,\\s*\\d+)?\\])?$`,
  "i"
);

/**
 * æ ¹æ®èŠ‚ç‚¹ç±»å‹éªŒè¯åç§°æ˜¯å¦ä¸ºæ’ä»¶ç”Ÿæˆ
 * @param node - Figma åœºæ™¯èŠ‚ç‚¹ï¼Œç”¨äºæ£€æŸ¥å…¶ç±»å‹å’Œå±æ€§
 * @param name - èŠ‚ç‚¹åç§°ï¼ˆå°å†™ï¼‰ï¼Œéœ€è¦éªŒè¯çš„åç§°å­—ç¬¦ä¸²
 * @returns {boolean} å¦‚æœåç§°ä¸èŠ‚ç‚¹ç±»å‹åŒ¹é…åˆ™è¿”å› true
 */
function isPluginGeneratedNameBasedOnType(
  node: SceneNode,
  name: string
): boolean {
  // ç§»é™¤å¯èƒ½çš„é—´è·ä¿¡æ¯åå†è¿›è¡ŒåŒ¹é…
  const baseName = name.replace(/-\[\d+(?:,\s*\d+)?\]$/, "");

  switch (baseName) {
    case "group":
      return node.type === "GROUP";
    case "frame":
    case "grid":
    case "row":
    case "col":
      return node.type === "FRAME";
    case "image":
    case "video":
      return (
        "fills" in node &&
        (node.fills as Paint[]).some(
          (fill) => fill.type === baseName.toUpperCase()
        )
      );
    case "union":
    case "subtract":
    case "intersect":
    case "exclude":
      return (
        node.type === "BOOLEAN_OPERATION" &&
        (node as BooleanOperationNode).booleanOperation.toLowerCase() ===
          baseName
      );
    default:
      return false;
  }
}

// åˆå§‹åŒ–å‘½åç­–ç•¥ç®¡ç†å™¨
const namingManager = new NamingStrategyManager();

/**
 * é‡å‘½åå•ä¸ªå›¾å±‚çš„æ ¸å¿ƒé€»è¾‘
 * åŒ…å«ä»¥ä¸‹åˆ¤æ–­ï¼š
 * 1. æ£€æŸ¥å›¾å±‚æ˜¯å¦éœ€è¦è·³è¿‡ï¼ˆé”å®š/éšè—/å®ä¾‹ï¼‰
 * 2. éªŒè¯æ˜¯å¦éœ€è¦é‡å‘½åï¼ˆè‡ªå®šä¹‰åç§°æˆ–è‡ªåŠ¨ç”Ÿæˆåç§°ï¼‰
 * 3. å¤„ç†å‘½åè§„åˆ™ï¼ˆå¦‚ PascalCaseï¼‰
 * @param node - éœ€è¦é‡å‘½åçš„ Figma åœºæ™¯èŠ‚ç‚¹
 * @param options - é‡å‘½åé…ç½®é€‰é¡¹ï¼ŒåŒ…å«æ˜¯å¦å¤„ç†é”å®š/éšè—/å®ä¾‹ç­‰è®¾ç½®
 * @returns {Promise<boolean>} å¦‚æœèŠ‚ç‚¹è¢«é‡å‘½ååˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› false
 * @throws å½“é‡å‘½åè¿‡ç¨‹å‡ºé”™æ—¶æŠ›å‡ºå¼‚å¸¸
 */
async function renameLayer(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  try {
    // æ ¹æ®é€‰é¡¹è·³è¿‡ç‰¹å®šç±»å‹çš„å›¾å±‚
    if (node.locked && !options.locked) return false;
    if (node.visible === false && !options.hidden) return false;
    if (node.type === "INSTANCE" && !options.instance) return false;

    // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å‘½å
    const shouldRename =
      options.renameCustomNames || isFigmaOrPluginGeneratedName(node);

    // æ·»åŠ å¼ºåˆ¶é‡å‘½åçš„æ¡ä»¶
    const isAutoGeneratedName = PLUGIN_NAME_PATTERN.test(node.name);
    const needsCaseUpdate = options.usePascalCase !== /^[A-Z]/.test(node.name);

    if (!shouldRename && !(isAutoGeneratedName && needsCaseUpdate)) {
      return false;
    }

    const newName = await namingManager.generateName(node, options);
    if (node.name !== newName) {
      node.name = newName;
      return true;
    }
    return false;
  } catch (error) {
    console.error(`é‡å‘½åé”™è¯¯ (${node.id}):`, error);
    figma.notify(`é‡å‘½åå¤±è´¥: ${node.name}`, { error: true });
    return false;
  }
}

/**
 * æ‰¹é‡å¤„ç†èŠ‚ç‚¹çš„é‡å‘½åæ“ä½œ
 * ä½¿ç”¨åˆ†æ‰¹å¤„ç†é¿å…æ€§èƒ½é—®é¢˜ï¼š
 * - æ¯æ‰¹å¤„ç† 50 ä¸ªèŠ‚ç‚¹
 * - æ‰¹æ¬¡é—´æ·»åŠ å¾®å°å»¶è¿Ÿé¿å…é˜»å¡ä¸»çº¿ç¨‹
 * @param nodes - éœ€è¦å¤„ç†çš„ Figma åœºæ™¯èŠ‚ç‚¹æ•°ç»„
 * @param options - é‡å‘½åé…ç½®é€‰é¡¹
 * @returns {Promise<boolean>} å¦‚æœä»»ä½•èŠ‚ç‚¹è¢«é‡å‘½ååˆ™è¿”å› true
 */
async function processBatchNodes(
  nodes: readonly SceneNode[],
  options: AllOptions
): Promise<boolean> {
  const batchSize = 50;
  let hasRenamed = false;

  for (let i = 0; i < nodes.length; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize);
    const results = await Promise.all(
      batch.map((node) => renameNodeAndChildren(node, options))
    );
    hasRenamed = hasRenamed || results.some((result) => result);

    // æ¯æ‰¹å¤„ç†å®Œåæš‚åœä¸€ä¸‹ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
    if (i + batchSize < nodes.length) {
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }

  return hasRenamed;
}

/**
 * é‡å‘½åé€‰ä¸­çš„å›¾å±‚
 * @param options é‡å‘½åé€‰é¡¹
 * @returns æ˜¯å¦æœ‰ä»»ä½•å›¾å±‚è¢«é‡å‘½å
 */
function renameLayersInSelection(options: AllOptions): Promise<boolean> {
  return new Promise(async (resolve) => {
    const selection = figma.currentPage.selection;
    const hasRenamed = await processBatchNodes(selection, options);
    resolve(hasRenamed);
  });
}

/**
 * æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åœ¨å®ä¾‹å†…
 * @param node - è¦æ£€æŸ¥çš„èŠ‚ç‚¹
 * @returns å¦‚æœèŠ‚ç‚¹åœ¨å®ä¾‹å†…åˆ™è¿”å› true
 */
function isInsideInstance(node: SceneNode): boolean {
  let currentNode: BaseNode | null = node;
  while (currentNode) {
    if (currentNode.type === "INSTANCE") {
      return true;
    }
    currentNode = currentNode.parent;
  }
  return false;
}

/**
 * é€’å½’å‡½æ•°ï¼Œç”¨äºé‡å‘½åèŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹
 * @param node è¦å¤„ç†çš„èŠ‚ç‚¹
 * @param options é‡å‘½åé€‰é¡¹
 * @returns æ˜¯å¦æœ‰ä»»ä½•èŠ‚ç‚¹è¢«é‡å‘½å
 */
async function renameNodeAndChildren(
  node: SceneNode,
  options: AllOptions
): Promise<boolean> {
  // å¦‚æœèŠ‚ç‚¹åœ¨å®ä¾‹å†…ä¸”æœªå¯ç”¨å®ä¾‹é‡å‘½åï¼Œç›´æ¥è¿”å›
  if (isInsideInstance(node) && !options.instance) {
    return false;
  }

  let hasRenamed = await renameLayer(node, options);

  // åªæœ‰åœ¨éå®ä¾‹èŠ‚ç‚¹æˆ–å¯ç”¨äº†å®ä¾‹é‡å‘½åçš„æƒ…å†µä¸‹æ‰å¤„ç†å­èŠ‚ç‚¹
  if ("children" in node && (node.type !== "INSTANCE" || options.instance)) {
    const childResults = await Promise.all(
      node.children.map((child) => renameNodeAndChildren(child, options))
    );
    hasRenamed = hasRenamed || childResults.some((result) => result);
  }

  return hasRenamed;
}

/**
 * åˆ¤æ–­èŠ‚ç‚¹åç§°æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆ
 * æ£€æŸ¥ä¸‰ç§æƒ…å†µï¼š
 * 1. æ–‡æœ¬èŠ‚ç‚¹çš„è‡ªåŠ¨é‡å‘½åæ ‡å¿—
 * 2. ç»„ä»¶ç›¸å…³çš„é»˜è®¤å‘½å
 * 3. Figma é»˜è®¤ç”Ÿæˆçš„åç§°
 * 4. æ’ä»¶ç”Ÿæˆçš„åç§°
 * @param node - è¦æ£€æŸ¥çš„ Figma åœºæ™¯èŠ‚ç‚¹
 * @returns {boolean} å¦‚æœèŠ‚ç‚¹åç§°æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„åˆ™è¿”å› true
 */
function isFigmaOrPluginGeneratedName(node: SceneNode): boolean {
  const name = node.name.toLowerCase();

  // éªŒè¯èŠ‚ç‚¹ç±»å‹
  if (!isValidFigmaNodeType(node.type)) {
    console.warn(`æœªçŸ¥çš„ Figma èŠ‚ç‚¹ç±»å‹: ${node.type}`);
    return false;
  }

  // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹
  if (node.type === "TEXT") {
    return (node as TextNode).autoRename || name === "text";
  }

  // ç»„ä»¶ç±»å‹çš„ç‰¹æ®Šå¤„ç†
  if (node.type === "COMPONENT" || node.type === "COMPONENT_SET") {
    return (
      name === "component" ||
      name === "componentset" ||
      figmaNameWithNumberRegex.test(name)
    );
  }

  // æ£€æŸ¥æ˜¯å¦ä¸º Figma ç”Ÿæˆçš„åç§°ï¼Œä¼ å…¥èŠ‚ç‚¹ç±»å‹è¿›è¡ŒåŒ¹é…
  if (isFigmaGeneratedName(node)) {
    return true;
  }

  // æ ¹æ®èŠ‚ç‚¹ç±»å‹å’Œåç§°çš„å…³ç³»åˆ¤æ–­æ˜¯å¦æ˜¯æ’ä»¶ç”Ÿæˆçš„åç§°
  return isPluginGeneratedNameBasedOnType(node, name);
}

/**
 * æ’ä»¶å…¥å£å‡½æ•°
 * ä¸»è¦èŒè´£ï¼š
 * 1. åˆå§‹åŒ– UI å’Œé…ç½®
 * 2. è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
 * 3. å¤„ç†ç”¨æˆ·äº¤äº’å’Œé‡å‘½åæ“ä½œ
 */
export default async function () {
  // åŠ è½½ä¿å­˜çš„è®¾ç½®
  const savedOptions: AllOptions = await loadSettingsAsync(
    {
      locked: false,
      hidden: false,
      instance: false,
      showSpacing: false,
      renameCustomNames: false,
      usePascalCase: false,
      language: "en", // æ·»åŠ é»˜è®¤è¯­è¨€è®¾ç½®
    },
    "allOptions"
  );

  // æ ¹æ®è¯­è¨€è®¾ç½®åˆå§‹é«˜åº¦
  const initialHeight = savedOptions.language === "zh" ? 262 : 246;

  // è®¾ç½® UI çª—å£å¤§å°
  const uiOptions = {
    width: 240,
    height: initialHeight,
  };

  const data = {
    savedOptions: savedOptions,
    initialSelection: figma.currentPage.selection.length > 0,
  };

  // æ˜¾ç¤º UI
  showUI(uiOptions, data);

  // ç›‘å¬é€‰ä¸­å˜åŒ–
  figma.on("selectionchange", () => {
    emit("SELECTION_CHANGED", figma.currentPage.selection.length > 0);
  });

  // ç›‘å¬ UI è®¾ç½®é¢æ¿å¼€å…³äº‹ä»¶
  on("SETTING_OPEN", (data: { settingOpen: boolean; language: string }) => {
    const baseHeight = data.language === "zh" ? 262 : 246;
    figma.ui.resize(240, data.settingOpen ? 456 : baseHeight);
  });

  // ç›‘å¬é‡å‘½åäº‹ä»¶
  on("RENAME", async (receivedOptions: AllOptions) => {
    try {
      // è®¾ç½®å®ä¾‹å­èŠ‚ç‚¹çš„å¯è§æ€§å¤„ç†
      figma.skipInvisibleInstanceChildren = !(
        receivedOptions.instance && receivedOptions.hidden
      );

      // ä¿å­˜ç”¨æˆ·çš„é€‰é¡¹
      await saveSettingsAsync(receivedOptions, "allOptions");

      // æ‰§è¡Œé‡å‘½åæ“ä½œ
      const hasRenamed = await renameLayersInSelection(receivedOptions);

      // æ˜¾ç¤ºæ“ä½œç»“æœé€šçŸ¥
      if (hasRenamed) {
        figma.notify("ğŸ‰ é‡å‘½åå®Œæˆï¼");
      } else {
        figma.notify("ğŸ˜¶â€ğŸŒ«ï¸ æ²¡æœ‰å›¾å±‚éœ€è¦é‡å‘½å");
      }
    } catch (error) {
      console.error("é‡å‘½åè¿‡ç¨‹å‡ºé”™:", error);
      figma.notify("âŒ é‡å‘½åè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯", { error: true });
    }
  });

  // æ·»åŠ ä¿å­˜è®¾ç½®çš„äº‹ä»¶ç›‘å¬
  on("SAVE_SETTINGS", async (options: AllOptions) => {
    try {
      await saveSettingsAsync(options, "allOptions");
    } catch (error) {
      console.error("ä¿å­˜è®¾ç½®å¤±è´¥:", error);
      figma.notify("è®¾ç½®ä¿å­˜å¤±è´¥", { error: true });
    }
  });
}
